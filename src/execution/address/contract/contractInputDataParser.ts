/* AutoGenerated Code, changes may be overwritten
 * INPUT GRAMMAR:
 * // To parse all arguments at once, separated by commas, start with Values instead
 * Start := _ valueObj=Value _ $
 *     .value = string | bigint | boolean | any[] { return this.valueObj.value; }
 * ValuesArray := '\[' _ elements=Values? _ '\]'
 *     .value = any[] { return this.elements ? this.elements.value : []; }
 * Values := head=Value _ tail={',' _ vals=Values}?
 *     .value = any[] { return (this.tail !== null) ? [this.head.value, ...this.tail.vals.value] : [this.head.value]; }
 * HexValue := value={'0x[a-f0-9]*'i}
 * UnsignedInteger := value={'[0-9]+'}
 * Integer := parts={sign='-'? abs=UnsignedInteger}
 *     .value = bigint { return BigInt((this.parts.sign ?? '') + this.parts.abs.value); }
 * FixedBig := integer=Integer decimal={'\.' value=UnsignedInteger}? 'e' exponent=UnsignedInteger
 *     .value = bigint {
 *         return (this.integer.value * 10n ** BigInt(this.exponent.value)) + (this.decimal !== null ? (BigInt(this.decimal.value.value) * 10n ** BigInt(BigInt(this.exponent.value) - BigInt(this.decimal.value.value.length))) * (this.integer.parts.sign === '-' ? -1n : 1n) : 0n);
 *     }
 * EscapeSequence := escaped={'\\' label='[n"\'\\]'}
 *     .char = string {
 *         switch (escaped.label) {
 *             case 'n':
 *                 return '\n';
 *             case '"':
 *                 return '"';
 *             case '\'':
 *                 return '\'';
 *             case '\\':
 *                 return '\\';
 *         }
 *         throw new Error('Unknown escape');
 *     }
 * Character := !'["\n\\]' char='.' | EscapeSequence
 * UnquotedString := chars={Character}*
 *     .value = string { return chars.map(c => c.char).join(''); }
 * QuotedString := '"' str=UnquotedString '"'
 *     .value = string { return str.value; }
 * Boolean := boolVal={'true' | 'false'}
 *     .value = boolean { return boolVal === 'true'; }
 * Value := ValuesArray | HexValue | FixedBig | Integer | QuotedString | Boolean
 * _ := '[ \t]*'
 */
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
  kind: ASTKinds;
}
export enum ASTKinds {
  Start = "Start",
  ValuesArray = "ValuesArray",
  Values = "Values",
  Values_$0 = "Values_$0",
  HexValue = "HexValue",
  HexValue_$0 = "HexValue_$0",
  UnsignedInteger = "UnsignedInteger",
  UnsignedInteger_$0 = "UnsignedInteger_$0",
  Integer = "Integer",
  Integer_$0 = "Integer_$0",
  FixedBig = "FixedBig",
  FixedBig_$0 = "FixedBig_$0",
  EscapeSequence = "EscapeSequence",
  EscapeSequence_$0 = "EscapeSequence_$0",
  Character_1 = "Character_1",
  Character_2 = "Character_2",
  UnquotedString = "UnquotedString",
  UnquotedString_$0 = "UnquotedString_$0",
  QuotedString = "QuotedString",
  Boolean = "Boolean",
  Boolean_$0_1 = "Boolean_$0_1",
  Boolean_$0_2 = "Boolean_$0_2",
  Value_1 = "Value_1",
  Value_2 = "Value_2",
  Value_3 = "Value_3",
  Value_4 = "Value_4",
  Value_5 = "Value_5",
  Value_6 = "Value_6",
  _ = "_",
  $EOF = "$EOF",
}
export class Start {
  public kind: ASTKinds.Start = ASTKinds.Start;
  public valueObj: Value;
  public value: string | bigint | boolean | any[];
  constructor(valueObj: Value) {
    this.valueObj = valueObj;
    this.value = ((): string | bigint | boolean | any[] => {
      return this.valueObj.value;
    })();
  }
}
export class ValuesArray {
  public kind: ASTKinds.ValuesArray = ASTKinds.ValuesArray;
  public elements: Nullable<Values>;
  public value: any[];
  constructor(elements: Nullable<Values>) {
    this.elements = elements;
    this.value = ((): any[] => {
      return this.elements ? this.elements.value : [];
    })();
  }
}
export class Values {
  public kind: ASTKinds.Values = ASTKinds.Values;
  public head: Value;
  public tail: Nullable<Values_$0>;
  public value: any[];
  constructor(head: Value, tail: Nullable<Values_$0>) {
    this.head = head;
    this.tail = tail;
    this.value = ((): any[] => {
      return this.tail !== null
        ? [this.head.value, ...this.tail.vals.value]
        : [this.head.value];
    })();
  }
}
export interface Values_$0 {
  kind: ASTKinds.Values_$0;
  vals: Values;
}
export interface HexValue {
  kind: ASTKinds.HexValue;
  value: HexValue_$0;
}
export type HexValue_$0 = string;
export interface UnsignedInteger {
  kind: ASTKinds.UnsignedInteger;
  value: UnsignedInteger_$0;
}
export type UnsignedInteger_$0 = string;
export class Integer {
  public kind: ASTKinds.Integer = ASTKinds.Integer;
  public parts: Integer_$0;
  public value: bigint;
  constructor(parts: Integer_$0) {
    this.parts = parts;
    this.value = ((): bigint => {
      return BigInt((this.parts.sign ?? "") + this.parts.abs.value);
    })();
  }
}
export interface Integer_$0 {
  kind: ASTKinds.Integer_$0;
  sign: Nullable<string>;
  abs: UnsignedInteger;
}
export class FixedBig {
  public kind: ASTKinds.FixedBig = ASTKinds.FixedBig;
  public integer: Integer;
  public decimal: Nullable<FixedBig_$0>;
  public exponent: UnsignedInteger;
  public value: bigint;
  constructor(
    integer: Integer,
    decimal: Nullable<FixedBig_$0>,
    exponent: UnsignedInteger
  ) {
    this.integer = integer;
    this.decimal = decimal;
    this.exponent = exponent;
    this.value = ((): bigint => {
      return (
        this.integer.value * 10n ** BigInt(this.exponent.value) +
        (this.decimal !== null
          ? BigInt(this.decimal.value.value) *
            10n **
              BigInt(
                BigInt(this.exponent.value) -
                  BigInt(this.decimal.value.value.length)
              ) *
            (this.integer.parts.sign === "-" ? -1n : 1n)
          : 0n)
      );
    })();
  }
}
export interface FixedBig_$0 {
  kind: ASTKinds.FixedBig_$0;
  value: UnsignedInteger;
}
export class EscapeSequence {
  public kind: ASTKinds.EscapeSequence = ASTKinds.EscapeSequence;
  public escaped: EscapeSequence_$0;
  public char: string;
  constructor(escaped: EscapeSequence_$0) {
    this.escaped = escaped;
    this.char = ((): string => {
      switch (escaped.label) {
        case "n":
          return "\n";
        case '"':
          return '"';
        case "'":
          return "'";
        case "\\":
          return "\\";
      }
      throw new Error("Unknown escape");
    })();
  }
}
export interface EscapeSequence_$0 {
  kind: ASTKinds.EscapeSequence_$0;
  label: string;
}
export type Character = Character_1 | Character_2;
export interface Character_1 {
  kind: ASTKinds.Character_1;
  char: string;
}
export type Character_2 = EscapeSequence;
export class UnquotedString {
  public kind: ASTKinds.UnquotedString = ASTKinds.UnquotedString;
  public chars: UnquotedString_$0[];
  public value: string;
  constructor(chars: UnquotedString_$0[]) {
    this.chars = chars;
    this.value = ((): string => {
      return chars.map((c) => c.char).join("");
    })();
  }
}
export type UnquotedString_$0 = Character;
export class QuotedString {
  public kind: ASTKinds.QuotedString = ASTKinds.QuotedString;
  public str: UnquotedString;
  public value: string;
  constructor(str: UnquotedString) {
    this.str = str;
    this.value = ((): string => {
      return str.value;
    })();
  }
}
export class Boolean {
  public kind: ASTKinds.Boolean = ASTKinds.Boolean;
  public boolVal: Boolean_$0;
  public value: boolean;
  constructor(boolVal: Boolean_$0) {
    this.boolVal = boolVal;
    this.value = ((): boolean => {
      return boolVal === "true";
    })();
  }
}
export type Boolean_$0 = Boolean_$0_1 | Boolean_$0_2;
export type Boolean_$0_1 = string;
export type Boolean_$0_2 = string;
export type Value = Value_1 | Value_2 | Value_3 | Value_4 | Value_5 | Value_6;
export type Value_1 = ValuesArray;
export type Value_2 = HexValue;
export type Value_3 = FixedBig;
export type Value_4 = Integer;
export type Value_5 = QuotedString;
export type Value_6 = Boolean;
export type _ = string;
export class Parser {
  private readonly input: string;
  private pos: PosInfo;
  private negating: boolean = false;
  private memoSafe: boolean = true;
  constructor(input: string) {
    this.pos = { overallPos: 0, line: 1, offset: 0 };
    this.input = input;
  }
  public reset(pos: PosInfo) {
    this.pos = pos;
  }
  public finished(): boolean {
    return this.pos.overallPos === this.input.length;
  }
  public clearMemos(): void {}
  public matchStart($$dpth: number, $$cr?: ErrorTracker): Nullable<Start> {
    return this.run<Start>($$dpth, () => {
      let $scope$valueObj: Nullable<Value>;
      let $$res: Nullable<Start> = null;
      if (
        true &&
        this.match_($$dpth + 1, $$cr) !== null &&
        ($scope$valueObj = this.matchValue($$dpth + 1, $$cr)) !== null &&
        this.match_($$dpth + 1, $$cr) !== null &&
        this.match$EOF($$cr) !== null
      ) {
        $$res = new Start($scope$valueObj);
      }
      return $$res;
    });
  }
  public matchValuesArray(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<ValuesArray> {
    return this.run<ValuesArray>($$dpth, () => {
      let $scope$elements: Nullable<Nullable<Values>>;
      let $$res: Nullable<ValuesArray> = null;
      if (
        true &&
        this.regexAccept(String.raw`(?:\[)`, "", $$dpth + 1, $$cr) !== null &&
        this.match_($$dpth + 1, $$cr) !== null &&
        (($scope$elements = this.matchValues($$dpth + 1, $$cr)) || true) &&
        this.match_($$dpth + 1, $$cr) !== null &&
        this.regexAccept(String.raw`(?:\])`, "", $$dpth + 1, $$cr) !== null
      ) {
        $$res = new ValuesArray($scope$elements);
      }
      return $$res;
    });
  }
  public matchValues($$dpth: number, $$cr?: ErrorTracker): Nullable<Values> {
    return this.run<Values>($$dpth, () => {
      let $scope$head: Nullable<Value>;
      let $scope$tail: Nullable<Nullable<Values_$0>>;
      let $$res: Nullable<Values> = null;
      if (
        true &&
        ($scope$head = this.matchValue($$dpth + 1, $$cr)) !== null &&
        this.match_($$dpth + 1, $$cr) !== null &&
        (($scope$tail = this.matchValues_$0($$dpth + 1, $$cr)) || true)
      ) {
        $$res = new Values($scope$head, $scope$tail);
      }
      return $$res;
    });
  }
  public matchValues_$0(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<Values_$0> {
    return this.run<Values_$0>($$dpth, () => {
      let $scope$vals: Nullable<Values>;
      let $$res: Nullable<Values_$0> = null;
      if (
        true &&
        this.regexAccept(String.raw`(?:,)`, "", $$dpth + 1, $$cr) !== null &&
        this.match_($$dpth + 1, $$cr) !== null &&
        ($scope$vals = this.matchValues($$dpth + 1, $$cr)) !== null
      ) {
        $$res = { kind: ASTKinds.Values_$0, vals: $scope$vals };
      }
      return $$res;
    });
  }
  public matchHexValue(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<HexValue> {
    return this.run<HexValue>($$dpth, () => {
      let $scope$value: Nullable<HexValue_$0>;
      let $$res: Nullable<HexValue> = null;
      if (
        true &&
        ($scope$value = this.matchHexValue_$0($$dpth + 1, $$cr)) !== null
      ) {
        $$res = { kind: ASTKinds.HexValue, value: $scope$value };
      }
      return $$res;
    });
  }
  public matchHexValue_$0(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<HexValue_$0> {
    return this.regexAccept(String.raw`(?:0x[a-f0-9]*)`, "i", $$dpth + 1, $$cr);
  }
  public matchUnsignedInteger(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<UnsignedInteger> {
    return this.run<UnsignedInteger>($$dpth, () => {
      let $scope$value: Nullable<UnsignedInteger_$0>;
      let $$res: Nullable<UnsignedInteger> = null;
      if (
        true &&
        ($scope$value = this.matchUnsignedInteger_$0($$dpth + 1, $$cr)) !== null
      ) {
        $$res = { kind: ASTKinds.UnsignedInteger, value: $scope$value };
      }
      return $$res;
    });
  }
  public matchUnsignedInteger_$0(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<UnsignedInteger_$0> {
    return this.regexAccept(String.raw`(?:[0-9]+)`, "", $$dpth + 1, $$cr);
  }
  public matchInteger($$dpth: number, $$cr?: ErrorTracker): Nullable<Integer> {
    return this.run<Integer>($$dpth, () => {
      let $scope$parts: Nullable<Integer_$0>;
      let $$res: Nullable<Integer> = null;
      if (
        true &&
        ($scope$parts = this.matchInteger_$0($$dpth + 1, $$cr)) !== null
      ) {
        $$res = new Integer($scope$parts);
      }
      return $$res;
    });
  }
  public matchInteger_$0(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<Integer_$0> {
    return this.run<Integer_$0>($$dpth, () => {
      let $scope$sign: Nullable<Nullable<string>>;
      let $scope$abs: Nullable<UnsignedInteger>;
      let $$res: Nullable<Integer_$0> = null;
      if (
        true &&
        (($scope$sign = this.regexAccept(
          String.raw`(?:-)`,
          "",
          $$dpth + 1,
          $$cr
        )) ||
          true) &&
        ($scope$abs = this.matchUnsignedInteger($$dpth + 1, $$cr)) !== null
      ) {
        $$res = {
          kind: ASTKinds.Integer_$0,
          sign: $scope$sign,
          abs: $scope$abs,
        };
      }
      return $$res;
    });
  }
  public matchFixedBig(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<FixedBig> {
    return this.run<FixedBig>($$dpth, () => {
      let $scope$integer: Nullable<Integer>;
      let $scope$decimal: Nullable<Nullable<FixedBig_$0>>;
      let $scope$exponent: Nullable<UnsignedInteger>;
      let $$res: Nullable<FixedBig> = null;
      if (
        true &&
        ($scope$integer = this.matchInteger($$dpth + 1, $$cr)) !== null &&
        (($scope$decimal = this.matchFixedBig_$0($$dpth + 1, $$cr)) || true) &&
        this.regexAccept(String.raw`(?:e)`, "", $$dpth + 1, $$cr) !== null &&
        ($scope$exponent = this.matchUnsignedInteger($$dpth + 1, $$cr)) !== null
      ) {
        $$res = new FixedBig($scope$integer, $scope$decimal, $scope$exponent);
      }
      return $$res;
    });
  }
  public matchFixedBig_$0(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<FixedBig_$0> {
    return this.run<FixedBig_$0>($$dpth, () => {
      let $scope$value: Nullable<UnsignedInteger>;
      let $$res: Nullable<FixedBig_$0> = null;
      if (
        true &&
        this.regexAccept(String.raw`(?:\.)`, "", $$dpth + 1, $$cr) !== null &&
        ($scope$value = this.matchUnsignedInteger($$dpth + 1, $$cr)) !== null
      ) {
        $$res = { kind: ASTKinds.FixedBig_$0, value: $scope$value };
      }
      return $$res;
    });
  }
  public matchEscapeSequence(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<EscapeSequence> {
    return this.run<EscapeSequence>($$dpth, () => {
      let $scope$escaped: Nullable<EscapeSequence_$0>;
      let $$res: Nullable<EscapeSequence> = null;
      if (
        true &&
        ($scope$escaped = this.matchEscapeSequence_$0($$dpth + 1, $$cr)) !==
          null
      ) {
        $$res = new EscapeSequence($scope$escaped);
      }
      return $$res;
    });
  }
  public matchEscapeSequence_$0(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<EscapeSequence_$0> {
    return this.run<EscapeSequence_$0>($$dpth, () => {
      let $scope$label: Nullable<string>;
      let $$res: Nullable<EscapeSequence_$0> = null;
      if (
        true &&
        this.regexAccept(String.raw`(?:\\)`, "", $$dpth + 1, $$cr) !== null &&
        ($scope$label = this.regexAccept(
          String.raw`(?:[n"\'\\])`,
          "",
          $$dpth + 1,
          $$cr
        )) !== null
      ) {
        $$res = { kind: ASTKinds.EscapeSequence_$0, label: $scope$label };
      }
      return $$res;
    });
  }
  public matchCharacter(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<Character> {
    return this.choice<Character>([
      () => this.matchCharacter_1($$dpth + 1, $$cr),
      () => this.matchCharacter_2($$dpth + 1, $$cr),
    ]);
  }
  public matchCharacter_1(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<Character_1> {
    return this.run<Character_1>($$dpth, () => {
      let $scope$char: Nullable<string>;
      let $$res: Nullable<Character_1> = null;
      if (
        true &&
        this.negate(() =>
          this.regexAccept(String.raw`(?:["\n\\])`, "", $$dpth + 1, $$cr)
        ) !== null &&
        ($scope$char = this.regexAccept(
          String.raw`(?:.)`,
          "",
          $$dpth + 1,
          $$cr
        )) !== null
      ) {
        $$res = { kind: ASTKinds.Character_1, char: $scope$char };
      }
      return $$res;
    });
  }
  public matchCharacter_2(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<Character_2> {
    return this.matchEscapeSequence($$dpth + 1, $$cr);
  }
  public matchUnquotedString(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<UnquotedString> {
    return this.run<UnquotedString>($$dpth, () => {
      let $scope$chars: Nullable<UnquotedString_$0[]>;
      let $$res: Nullable<UnquotedString> = null;
      if (
        true &&
        ($scope$chars = this.loop<UnquotedString_$0>(
          () => this.matchUnquotedString_$0($$dpth + 1, $$cr),
          0,
          -1
        )) !== null
      ) {
        $$res = new UnquotedString($scope$chars);
      }
      return $$res;
    });
  }
  public matchUnquotedString_$0(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<UnquotedString_$0> {
    return this.matchCharacter($$dpth + 1, $$cr);
  }
  public matchQuotedString(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<QuotedString> {
    return this.run<QuotedString>($$dpth, () => {
      let $scope$str: Nullable<UnquotedString>;
      let $$res: Nullable<QuotedString> = null;
      if (
        true &&
        this.regexAccept(String.raw`(?:")`, "", $$dpth + 1, $$cr) !== null &&
        ($scope$str = this.matchUnquotedString($$dpth + 1, $$cr)) !== null &&
        this.regexAccept(String.raw`(?:")`, "", $$dpth + 1, $$cr) !== null
      ) {
        $$res = new QuotedString($scope$str);
      }
      return $$res;
    });
  }
  public matchBoolean($$dpth: number, $$cr?: ErrorTracker): Nullable<Boolean> {
    return this.run<Boolean>($$dpth, () => {
      let $scope$boolVal: Nullable<Boolean_$0>;
      let $$res: Nullable<Boolean> = null;
      if (
        true &&
        ($scope$boolVal = this.matchBoolean_$0($$dpth + 1, $$cr)) !== null
      ) {
        $$res = new Boolean($scope$boolVal);
      }
      return $$res;
    });
  }
  public matchBoolean_$0(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<Boolean_$0> {
    return this.choice<Boolean_$0>([
      () => this.matchBoolean_$0_1($$dpth + 1, $$cr),
      () => this.matchBoolean_$0_2($$dpth + 1, $$cr),
    ]);
  }
  public matchBoolean_$0_1(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<Boolean_$0_1> {
    return this.regexAccept(String.raw`(?:true)`, "", $$dpth + 1, $$cr);
  }
  public matchBoolean_$0_2(
    $$dpth: number,
    $$cr?: ErrorTracker
  ): Nullable<Boolean_$0_2> {
    return this.regexAccept(String.raw`(?:false)`, "", $$dpth + 1, $$cr);
  }
  public matchValue($$dpth: number, $$cr?: ErrorTracker): Nullable<Value> {
    return this.choice<Value>([
      () => this.matchValue_1($$dpth + 1, $$cr),
      () => this.matchValue_2($$dpth + 1, $$cr),
      () => this.matchValue_3($$dpth + 1, $$cr),
      () => this.matchValue_4($$dpth + 1, $$cr),
      () => this.matchValue_5($$dpth + 1, $$cr),
      () => this.matchValue_6($$dpth + 1, $$cr),
    ]);
  }
  public matchValue_1($$dpth: number, $$cr?: ErrorTracker): Nullable<Value_1> {
    return this.matchValuesArray($$dpth + 1, $$cr);
  }
  public matchValue_2($$dpth: number, $$cr?: ErrorTracker): Nullable<Value_2> {
    return this.matchHexValue($$dpth + 1, $$cr);
  }
  public matchValue_3($$dpth: number, $$cr?: ErrorTracker): Nullable<Value_3> {
    return this.matchFixedBig($$dpth + 1, $$cr);
  }
  public matchValue_4($$dpth: number, $$cr?: ErrorTracker): Nullable<Value_4> {
    return this.matchInteger($$dpth + 1, $$cr);
  }
  public matchValue_5($$dpth: number, $$cr?: ErrorTracker): Nullable<Value_5> {
    return this.matchQuotedString($$dpth + 1, $$cr);
  }
  public matchValue_6($$dpth: number, $$cr?: ErrorTracker): Nullable<Value_6> {
    return this.matchBoolean($$dpth + 1, $$cr);
  }
  public match_($$dpth: number, $$cr?: ErrorTracker): Nullable<_> {
    return this.regexAccept(String.raw`(?:[ \t]*)`, "", $$dpth + 1, $$cr);
  }
  public test(): boolean {
    const mrk = this.mark();
    const res = this.matchStart(0);
    const ans = res !== null;
    this.reset(mrk);
    return ans;
  }
  public parse(): ParseResult {
    const mrk = this.mark();
    const res = this.matchStart(0);
    if (res) return { ast: res, errs: [] };
    this.reset(mrk);
    const rec = new ErrorTracker();
    this.clearMemos();
    this.matchStart(0, rec);
    const err = rec.getErr();
    return { ast: res, errs: err !== null ? [err] : [] };
  }
  public mark(): PosInfo {
    return this.pos;
  }
  // @ts-ignore: loopPlus may not be called
  private loopPlus<T>(func: $$RuleType<T>): Nullable<[T, ...T[]]> {
    return this.loop(func, 1, -1) as Nullable<[T, ...T[]]>;
  }
  private loop<T>(func: $$RuleType<T>, lb: number, ub: number): Nullable<T[]> {
    const mrk = this.mark();
    const res: T[] = [];
    while (ub === -1 || res.length < ub) {
      const preMrk = this.mark();
      const t = func();
      if (t === null || this.pos.overallPos === preMrk.overallPos) {
        break;
      }
      res.push(t);
    }
    if (res.length >= lb) {
      return res;
    }
    this.reset(mrk);
    return null;
  }
  private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
    const mrk = this.mark();
    const res = fn();
    if (res !== null) return res;
    this.reset(mrk);
    return null;
  }
  // @ts-ignore: choice may not be called
  private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
    for (const f of fns) {
      const res = f();
      if (res !== null) {
        return res;
      }
    }
    return null;
  }
  private regexAccept(
    match: string,
    mods: string,
    dpth: number,
    cr?: ErrorTracker
  ): Nullable<string> {
    return this.run<string>(dpth, () => {
      const reg = new RegExp(match, "y" + mods);
      const mrk = this.mark();
      reg.lastIndex = mrk.overallPos;
      const res = this.tryConsume(reg);
      if (cr) {
        cr.record(mrk, res, {
          kind: "RegexMatch",
          // We substring from 3 to len - 1 to strip off the
          // non-capture group syntax added as a WebKit workaround
          literal: match.substring(3, match.length - 1),
          negated: this.negating,
        });
      }
      return res;
    });
  }
  private tryConsume(reg: RegExp): Nullable<string> {
    const res = reg.exec(this.input);
    if (res) {
      let lineJmp = 0;
      let lind = -1;
      for (let i = 0; i < res[0].length; ++i) {
        if (res[0][i] === "\n") {
          ++lineJmp;
          lind = i;
        }
      }
      this.pos = {
        overallPos: reg.lastIndex,
        line: this.pos.line + lineJmp,
        offset:
          lind === -1
            ? this.pos.offset + res[0].length
            : res[0].length - lind - 1,
      };
      return res[0];
    }
    return null;
  }
  // @ts-ignore: noConsume may not be called
  private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
    const mrk = this.mark();
    const res = fn();
    this.reset(mrk);
    return res;
  }
  // @ts-ignore: negate may not be called
  private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
    const mrk = this.mark();
    const oneg = this.negating;
    this.negating = !oneg;
    const res = fn();
    this.negating = oneg;
    this.reset(mrk);
    return res === null ? true : null;
  }
  // @ts-ignore: Memoise may not be used
  private memoise<K>(
    rule: $$RuleType<K>,
    memo: Map<number, [Nullable<K>, PosInfo]>
  ): Nullable<K> {
    const $scope$pos = this.mark();
    const $scope$memoRes = memo.get($scope$pos.overallPos);
    if (this.memoSafe && $scope$memoRes !== undefined) {
      this.reset($scope$memoRes[1]);
      return $scope$memoRes[0];
    }
    const $scope$result = rule();
    if (this.memoSafe)
      memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
    return $scope$result;
  }
  private match$EOF(et?: ErrorTracker): Nullable<{ kind: ASTKinds.$EOF }> {
    const res: { kind: ASTKinds.$EOF } | null = this.finished()
      ? { kind: ASTKinds.$EOF }
      : null;
    if (et)
      et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
    return res;
  }
}
export function parse(s: string): ParseResult {
  const p = new Parser(s);
  return p.parse();
}
export interface ParseResult {
  ast: Nullable<Start>;
  errs: SyntaxErr[];
}
export interface PosInfo {
  readonly overallPos: number;
  readonly line: number;
  readonly offset: number;
}
export interface RegexMatch {
  readonly kind: "RegexMatch";
  readonly negated: boolean;
  readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
  public pos: PosInfo;
  public expmatches: MatchAttempt[];
  constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
    this.pos = pos;
    this.expmatches = [...expmatches];
  }
  public toString(): string {
    return `Syntax Error at line ${this.pos.line}:${
      this.pos.offset
    }. Expected one of ${this.expmatches.map((x) =>
      x.kind === "EOF" ? " EOF" : ` ${x.negated ? "not " : ""}'${x.literal}'`
    )}`;
  }
}
class ErrorTracker {
  private mxpos: PosInfo = { overallPos: -1, line: -1, offset: -1 };
  private regexset: Set<string> = new Set();
  private pmatches: MatchAttempt[] = [];
  public record(pos: PosInfo, result: any, att: MatchAttempt) {
    if ((result === null) === att.negated) return;
    if (pos.overallPos > this.mxpos.overallPos) {
      this.mxpos = pos;
      this.pmatches = [];
      this.regexset.clear();
    }
    if (this.mxpos.overallPos === pos.overallPos) {
      if (att.kind === "RegexMatch") {
        if (!this.regexset.has(att.literal)) this.pmatches.push(att);
        this.regexset.add(att.literal);
      } else {
        this.pmatches.push(att);
      }
    }
  }
  public getErr(): SyntaxErr | null {
    if (this.mxpos.overallPos !== -1)
      return new SyntaxErr(this.mxpos, this.pmatches);
    return null;
  }
}
